Pattern: [ASSERT,EXPECT]_

[TRUE,FALSE] (boolean)
[EQ,NE](expected, actual) (equable (most) types)
[LT,LE,GT,GE] (comparable types)
[STREQ,STRNE,STRCASEEQ,STRCASENE] for C-strings
[FLOAT_EQ,DOUBLE_EQ](expected, actual) floating pointer numbers (with implicit range)
[NEAR](expected, actual, absolute_range) floating pointer numbers (with explicit absolute_range)
THAT(expression, m), generic matcher assertion: true if expression matcher matcher m

Important: In order for diagnostics to be correct for ...EQ/NEQ-functions the first parameter should be the expected value (in some cases constant) and the second should be the one calculated by function under test.

Two kinds of behaviour on failures:

Fatal: starts with ASSERT and stops execution
Non-fatal: starts with EXPECT and continues execution
//
TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(1, Factorial(0));
}

TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(1, Factorial(1));
  EXPECT_EQ(2, Factorial(2));
  EXPECT_EQ(6, Factorial(3));
  EXPECT_EQ(40320, Factorial(8));
}
Here,

the test case named FactorialTest contains
the two tests named HandlesZeroInput and HandlesPositiveInput.
//

Tests can be disabled by prefixing the symbolic name of either test case or the test with the string DISABLE_.
 A warning will be printed at the end of the test execution if there are any disabled tests.
 The flag -gtest_also_run_disabled_tests overrides this behaviour and runs all the disabled tests aswell.
//

Use EXPECT_* when you want the test to continue to reveal more errors after the assertion failure,
and use ASSERT_* when continuing after failure doesn't make sense.
//

The typical C/C++ main() function looks like

## tests and fixtures ...

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
